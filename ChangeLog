Fri Mar 13 02:42:33 GMT 2009  Jon Harrop <jon@ffconsultancy.com>

	* Switched from LLVM's malloc intrinsic to helper functions for alloc
	(using calloc in order to initialize references to NULL) and free.
	* Optimized the GC to use a hash table instead of linear search,
	improving performance by up to 100x on our benchmarks.
	* Avoided resetting the shadow stack at the ends of functions that do
	not push any roots onto it.


Wed Mar 11 21:05:44 GMT 2009  Jon Harrop <jon@ffconsultancy.com>

	* Chose to put new LLVM bindings into the HLVM project instead of
	patching LLVM. We now have bindings for BuildExtractValue,
	BuildInsertValue and for enabling tail call optimization globally.


Wed Mar 11 04:01:45 GMT 2009  Jon Harrop <jon@ffconsultancy.com>

	* Tidied the run-time type code to reuse HLVM's own structs.
	* Fixed a perf bug where reading a reference type from a bound
	variable was pushing it onto the shadow stack. Sieve is now 70% faster.
	* Fixed a bug in init_type which was invoking a fastcc function when it
	should have been using the C calling convention.
	* Added dummy arguments to all argumentless invocations to work around
	a bug in LLVM's OCaml bindings, which calls malloc for zero bytes
	(which is illegal) if there are zero arguments.


Mon Mar  9 12:31:16 GMT 2009  Jon Harrop <jon@ffconsultancy.com>

	* Fixed the GC to use an explicit "visit stack" instead of the system
	stack. This eliminates the stack overflow bug that prevented the list
	test from running to completion but the current GC is so slow that
	I still have not run this test to completion.


Sun Mar  8 04:23:30 GMT 2009  Jon Harrop <jon@ffconsultancy.com>

	* Prepared for first public release.


Fri Mar  6 01:56:13 GMT 2009  Jon Harrop <jon@ffconsultancy.com>

	* Made the "expr" and "def" functions mutually recursive so the 
	compilation of an expression can trigger the compilation of an
	auxiliary function that it depends upon.
	* Implemented a simple stop-the-world mark and sweep garbage collector
	written in the HLVM language itself.
	* A new `UnsafeFunction top-level statement defines a function without
	injecting any code for the GC.
	* Ordinary functions call gc_root to register a local root into the
	heap (e.g. when loading a reference type) by pushing it onto the shadow
	stack, call gc_alloc when a value is allocated to push it onto the
	allocated list and gc_restore when a function returns to unwind the
	shadow stack.


Tue Mar  3 02:38:35 GMT 2009  Jon Harrop <jon@ffconsultancy.com>

	* Realised that the current functionality can already be used to
	represent closures as a function pointer and a reference type
	containing the environment. Added some tests that use this.


Wed Feb 25 21:20:26 GMT 2009  Jon Harrop <jon@ffconsultancy.com>

	* Made ffib benchmark 50% faster by swapping the branches of the "if"
	expression: most common branch should go first.
	* Added code to Printf to handle 32-bit floats by extending them to
	64-bit floats for printing.


Wed Feb 25 03:22:42 GMT 2009  Jon Harrop <jon@ffconsultancy.com>

	* Added OCaml bindings to the new ExtractElement and InsertElement
	instructions now in LLVM's C bindings. This has improved performance
	a lot: Mandelbrot3 (with complex arithmetic) is now 3.5x faster and
	HLVM is faster than OCaml on every test.


Sun Feb 22 16:14:10 GMT 2009  Jon Harrop <jon@ffconsultancy.com>

	* First implementation of reference types represented as a struct
	containing a pointer to the type and a pointer to the argument (if
	any). This allows typed NULL references which should permit efficient
	implementation of properly-typed linked lists.
	* Returning first-class structs inhibits TCO so we must sret all struct
	return types, which I have now done.
	* Removed a layer of indirection in the representation of arrays, which
	is now a struct containing the type, length and pointer to heap data.
	* Fixed with respect to all existing tests. Array performance has
	degraded slightly due to the current overhead of structs.


Thu Feb 19 23:23:25 GMT 2009  Jon Harrop <jon@ffconsultancy.com>

	* build_allocas must go in the entry block of a function. Altered
	state#alloca to insert at the end of the entry block and tweaked the
	compilation of "if" expressions to insert the final jump from the
	previous block only after compilation of both branches is complete, so
	they insert their allocas before the branch.
	* Lots of optimization passes are not yet available from OCaml but
	they could do a great deal with our code, particularly our inefficient
	struct code.
	* Reference type is a struct with a pointer to the type and a pointer
	to the argument. That allows NULL to be typed.


Fri Feb  6 01:39:13 GMT 2009  Jon Harrop <jon@ffconsultancy.com>

	* Added structs but they are locally allocated so they cannot be
	passed in the arguments to a tail call.
	* Used an ingenious workaround: copy every struct into an alloca in
	order to use gep until extractvalue is implemented.
	* Fixed a bug caused by marking every call as a tail call when this
	can confuse LLVM's (CSE) optimization pass.


Tue Jan 27 00:47:10 GMT 2009  Jon Harrop <jon@ffconsultancy.com>

	* Extended sieve and mandelbrot examples to illustrate segmentation
	fault due to stack overflow due to non-tail calls.
	* Introduced a Return constructor into the Expr.t type to handle tail
	calls properly.
	* Added first-class function pointers by casting all defined functions
	into pointer types before binding them to their variable name.


Sun Jan 25 06:51:00 GMT 2009  Jon Harrop <jon@ffconsultancy.com>

	* Clean design with "expr" checking all types including return types.
	* FastCC but no propagation of tail calls into final expressions.
	* No extern functions.
	* No first-class function pointers.
	* No run-time types.
	* No shadow stack.
	* No tuples or multiple return values: functions accept multiple
	arguments but return only one result.
